<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Poker Blinds Timer</title>
  <style>
    :root{
      --bg:#071029; --muted:#94a3b8; --accent:#e23b3b; --glass:rgba(255,255,255,0.03);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:linear-gradient(180deg,#071029 0%, #061621 100%); color:#e6eef6;
      padding:28px; min-height:100vh; display:flex; align-items:flex-start; justify-content:center;
    }
    .container{width:900px; display:grid; grid-template-columns:1fr; gap:20px; position:relative;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.04); padding:18px; border-radius:12px; position:relative;}

    .timer-card{display:flex; gap:20px; align-items:center; justify-content:space-between; padding:28px;}
    .left{ flex:1; display:flex; flex-direction:column; gap:12px; align-items:flex-start; }
    .tournament-title{font-weight:700; font-size:18px}
    .round{color:var(--muted); font-size:13px}

    .blinds-hero{ width:100%; display:flex; gap:18px; align-items:center; }
    .big-blind{
      flex:1; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border:1px solid rgba(255,255,255,0.04); padding:24px; border-radius:12px; text-align:center;
      transition: box-shadow .12s, transform .12s, background-color .12s;
    }
    .big-blind .label{color:var(--muted); font-size:13px; margin-bottom:6px}
    .big-blind .value{font-size:56px; font-weight:900; letter-spacing:2px}
    .big-blind .sub{color:#ffd100; font-weight:800; margin-top:8px}

    .next-blind{ width:220px; background:var(--glass); padding:14px; border-radius:10px; text-align:center; }
    .next-blind .label{color:var(--muted); font-size:12px}
    .next-blind .value{font-size:20px; font-weight:800; margin-top:6px}

    @keyframes flashPulse {
      0% { box-shadow: 0 0 0 0 rgba(255,209,0,0.0); transform: scale(1); }
      30% { box-shadow: 0 0 24px 6px rgba(255,209,0,0.18); transform: scale(1.03); }
      60% { box-shadow: 0 0 12px 3px rgba(255,209,0,0.12); transform: scale(1.01); }
      100% { box-shadow: 0 0 0 0 rgba(255,209,0,0.0); transform: scale(1); }
    }
    /* .flash will be applied while repeating; animation-duration is set dynamically by JS via style */
    .flash { animation-name: flashPulse; animation-timing-function: ease-in-out; animation-iteration-count: infinite; }

    .timer-small{
      width:220px; text-align:center; padding:14px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03);
    }
    .countdown-small{font-size:28px; font-weight:800; margin:8px 0}
    .controls{display:flex; gap:10px; margin-top:12px; justify-content:center; flex-wrap:wrap}
    .btn{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.06); padding:8px 12px; border-radius:8px; color:inherit; cursor:pointer; font-weight:700;}
    .btn.primary{background:linear-gradient(180deg,#e23b3b,#c02828); color:#fff; border:0}
    .btn.ghost{background:transparent}

    .status{margin-top:10px; font-size:13px; color:var(--muted); text-align:center}
    .overlay-open-btn{ position:absolute; right:28px; top:28px; z-index:5; background:rgba(2,6,23,0.6); border:1px solid rgba(255,255,255,0.06); color:#e6eef6; padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:700; backdrop-filter: blur(4px); }

    /* Fullscreen fallback pseudo-fullscreen class (useful on iOS) */
    .fs-fullscreen {
      position: fixed !important;
      inset: 0 !important;
      width: 100vw !important;
      height: 100vh !important;
      margin: 0 !important;
      border-radius: 0 !important;
      z-index: 99999 !important;
      background: linear-gradient(180deg,#071029 0%, #061621 100%) !important;
      overflow: auto !important;
    }

    .overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:flex-end; pointer-events:none; }
    .overlay-backdrop { position:absolute; inset:0; background:rgba(0,0,0,0.45); opacity:0; transition:opacity .2s; pointer-events:none; }
    .panel { width:380px; max-width:92vw; height:100vh; transform:translateX(110%); transition:transform .25s; background:linear-gradient(180deg, rgba(10,14,20,0.98), rgba(6,10,14,0.98)); padding:20px; box-shadow: -20px 0 40px rgba(0,0,0,0.6); pointer-events:auto; overflow:auto; }
    .panel.open{ transform:translateX(0); }
    .overlay.open .overlay-backdrop{ opacity:1; pointer-events:auto; }

    h4{margin:0 0 10px 0; font-size:16px; color:var(--muted)}
    .small{font-size:12px; color:var(--muted)}
    table{width:100%; border-collapse:collapse; font-size:13px; color:#dbe9ff}
    thead th{font-size:12px; color:var(--muted); font-weight:600; text-align:left; padding:8px}
    td{padding:6px 8px; vertical-align:middle}
    tbody tr{border-top:1px solid rgba(255,255,255,0.02); cursor:pointer}
    tbody tr:hover{background:rgba(255,255,255,0.01)}
    .level-current{background:linear-gradient(90deg, rgba(226,59,59,0.10), rgba(226,59,59,0.04)); color:#fff; font-weight:700}
    input[type="text"], input[type="number"]{ width:100%; background:transparent; border:0; color:inherit; padding:6px; font-size:13px; }
    input[type="number"]{ text-align:right; }
    .panel .structure-actions{display:flex; gap:8px; margin-top:10px}
    .panel .close-btn{position:absolute; left:12px; top:12px; background:transparent; border:0; color:var(--muted); cursor:pointer; font-weight:700}
    @media (max-width:720px){
      .timer-card{flex-direction:column; align-items:stretch;}
      .big-blind .value{font-size:44px}
      .next-blind, .timer-small{width:100%}
      .overlay-open-btn{ right:12px; top:12px; }
    }

.timer-large {
  width: 100%;
  text-align: center;
  padding: 24px;
  border-radius: 12px;
  background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.015));
  border: 1px solid rgba(255,255,255,0.05);
  margin-bottom: 20px; /* spacing below timer */
}

.timer-large .label {
  font-size: 16px;
  color: var(--muted);
  margin-bottom: 8px;
}

.countdown-large {
  font-size: 64px;   /* enlarged countdown */
  font-weight: 900;
  margin: 12px 0;
  letter-spacing: 2px;
}

#zoom-in-btn, #zoom-out-btn {
  min-width: 100px;
}

  </style>
</head>
<body>
  <div class="container">
    <div class="card timer-card" id="timer-area">
  <button class="overlay-open-btn btn" id="open-structure">Structure</button>

  <!-- Timer moved to top -->
  <div class="timer-large" aria-label="timer controls">
    <div class="label">Time Remaining</div>
    <div id="countdown" class="countdown-large">10:00</div>

    <div class="controls" role="toolbar" aria-label="timer buttons">
      <button id="start-btn" class="btn primary">Start</button>
      <button id="pause-btn" class="btn">Pause</button>
      <button id="restart-btn" class="btn">Restart the clock</button>
      <button id="restart-one-btn" class="btn ghost">Restart the game</button>
      <button id="fullscreen-btn" class="btn">Enter Fullscreen</button>

  <!-- New zoom buttons -->
  <button id="zoom-in-btn" class="btn">Zoom In</button>
  <button id="zoom-out-btn" class="btn">Zoom Out</button>
</div>

    <div id="status" class="status">Ready</div>
  </div>
  
      <div class="left">
        <div>
          <div class="tournament-title">Poker Blinds Timer</div>
          <div id="round-label" class="round">Round 1</div>
        </div>

        <div class="blinds-hero">
          <div class="big-blind" id="big-blind" aria-live="polite">
            <div class="label">Current Blinds</div>
            <div id="current-blinds" class="value">200 / 400</div>
            <div id="big-sub" class="sub">Level 1</div>
          </div>

          <div class="next-blind" aria-live="polite">
            <div class="label">Next Blinds</div>
            <div id="next-blinds" class="value">400 / 800</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="overlay" aria-hidden="true">
    <div class="overlay-backdrop" id="overlay-backdrop"></div>
    <aside class="panel" id="panel" role="dialog" aria-label="Structure panel">
      <button class="close-btn" id="close-panel">Close</button>
      <h4>Structure</h4>
      <p class="small">Edit blinds and duration inline. Add or remove levels. Click Select to set current.</p>

      <table aria-label="blind structure" id="structure-table">
        <thead>
          <tr><th style="width:18%;">Level</th><th style="width:52%;">Blinds</th><th style="width:20%;">Duration</th><th style="width:10%;"></th></tr>
        </thead>
        <tbody id="structure-body"></tbody>
      </table>

      <div class="structure-actions">
        <button id="add-level" class="btn">Add Level</button>
        <button id="add-break" class="btn">Add Break</button>
        <button id="remove-level" class="btn">Remove Selected</button>
      </div>
    </aside>
  </div>

  <script>
    (function(){
      // Overlay open/close
      const openBtn = document.getElementById('open-structure');
      const overlay = document.getElementById('overlay');
      const panel = document.getElementById('panel');
      const backdrop = document.getElementById('overlay-backdrop');
      const closeBtn = document.getElementById('close-panel');

      function openPanel(){ overlay.classList.add('open'); panel.classList.add('open'); overlay.setAttribute('aria-hidden','false'); setTimeout(()=>{ const inp = panel.querySelector('input'); if(inp) inp.focus(); }, 250); }
      function closePanel(){ overlay.classList.remove('open'); panel.classList.remove('open'); overlay.setAttribute('aria-hidden','true'); }
      openBtn.addEventListener('click', openPanel);
      closeBtn.addEventListener('click', closePanel);
      backdrop.addEventListener('click', closePanel);
      document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closePanel(); });

      // Elements
      const structureBody = document.getElementById('structure-body');
      const addLevelBtn = document.getElementById('add-level');
      const addBreakBtn = document.getElementById('add-break');
      const removeLevelBtn = document.getElementById('remove-level');

      const countdownEl = document.getElementById('countdown');
      const currentBlindsEl = document.getElementById('current-blinds');
      const nextBlindsEl = document.getElementById('next-blinds');
      const roundLabel = document.getElementById('round-label');
      const bigSub = document.getElementById('big-sub');
      const statusEl = document.getElementById('status');
      const bigBlindBlock = document.getElementById('big-blind');

      const startBtn = document.getElementById('start-btn');
      const pauseBtn = document.getElementById('pause-btn');
      const restartBtn = document.getElementById('restart-btn');
      const restartToOneBtn = document.getElementById('restart-one-btn');
      const zoomInBtn = document.getElementById('zoom-in-btn');
      const zoomOutBtn = document.getElementById('zoom-out-btn');

      // Fullscreen elements
      const fsBtn = document.getElementById('fullscreen-btn');
      const fsTarget = document.getElementById('timer-area') || document.documentElement;
      let fallbackActive = false;

      // State
      let rows = [];
      let selectedId = null;
      let currentIndex = 0;
      let timer = null;
      let remaining = 0;
      let initialRemaining = 0;
      let playing = false;

      // Repeating beep/flash handles
      let repeatingBeepInterval = null;
      let repeatingFlashActive = false;

      // Audio context
      let audioCtx = null;
      function ensureAudioContext(){
        if(!audioCtx){
          try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
          catch(e){ audioCtx = null; }
        }
        return audioCtx;
      }

      function playBeepOnce(duration = 0.12, frequency = 1200, type = 'sine', volume = 0.18){
        const ctx = ensureAudioContext();
        if(!ctx) return;
        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(frequency, now);
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(now);
        osc.stop(now + duration + 0.02);
      }

      // Start repeating beeps at intervalMs; returns a function to stop them
      function startRepeatingBeeps(intervalMs = 400){
        stopRepeatingBeeps();
        // ensure audio resume if required
        const ctx = ensureAudioContext();
        if(ctx && ctx.state === 'suspended') { ctx.resume().catch(()=>{}); }
        playBeepOnce(); // immediate
        repeatingBeepInterval = setInterval(() => playBeepOnce(), intervalMs);
      }
      function stopRepeatingBeeps(){
        if(repeatingBeepInterval){ clearInterval(repeatingBeepInterval); repeatingBeepInterval = null; }
      }

      // Flash: add .flash with animation duration set to pulseMs; remove when stopped
      function startRepeatingFlash(pulseMs = 600){
        stopRepeatingFlash();
        repeatingFlashActive = true;
        bigBlindBlock.classList.add('flash');
        // set animation duration to match pulse length
        bigBlindBlock.style.animationDuration = (pulseMs/1000) + 's';
      }
      function stopRepeatingFlash(){
        repeatingFlashActive = false;
        bigBlindBlock.classList.remove('flash');
        bigBlindBlock.style.animationDuration = '';
      }

      // Utility: start repeated cues for a total durationMs, then call callback once
      function runRepeatedCues(totalDurationMs = 2500, beepIntervalMs = 500, pulseMs = 500, callback){
        // Stop any previous repeats
        stopRepeatingBeeps();
        stopRepeatingFlash();
        // Start
        startRepeatingBeeps(beepIntervalMs);
        startRepeatingFlash(pulseMs);
        // Ensure single scheduled advance
        const endTimer = setTimeout(() => {
          stopRepeatingBeeps();
          stopRepeatingFlash();
          callback && callback();
        }, totalDurationMs);
        return () => {
          clearTimeout(endTimer);
          stopRepeatingBeeps();
          stopRepeatingFlash();
        };
      }

      // ID helpers
      function uid(){ return 'lvl_' + Math.random().toString(36).slice(2,9); }
      function createRowObj(type='level', label='', blinds='', duration=10){ return { id: uid(), type, label, blinds, duration: Number(duration) || 1 }; }
      function escapeHtml(text){ return (''+text).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }

      // Render structure table
      function renderRows(){
        structureBody.innerHTML = '';
        rows.forEach((r, idx) => {
          const tr = document.createElement('tr');
          tr.dataset.id = r.id;
          if(idx === currentIndex) tr.classList.add('level-current');
          tr.innerHTML = `
            <td>${r.type === 'break' ? 'Break' : (r.label || idx+1)}</td>
            <td>${r.type === 'break' ? '<span style="opacity:.6">-</span>' : `<input type="text" data-field="blinds" value="${escapeHtml(r.blinds)}" />`}</td>
            <td><input type="number" ${r.type==='break' ? '' : 'data-field="duration"'} min="1" value="${r.duration}" style="width:70px" />m</td>
            <td style="text-align:right"><button class="btn" data-action="select">Select</button></td>
          `;
          structureBody.appendChild(tr);

          tr.querySelector('[data-action="select"]').addEventListener('click', (e) => {
            e.stopPropagation();
            selectRow(r.id);
            setCurrentById(r.id);
            closePanel();
          });

          tr.addEventListener('click', () => selectRow(r.id));

          const blindsInput = tr.querySelector('input[data-field="blinds"]');
          const durInput = tr.querySelector('input[data-field="duration"]');

          if(blindsInput){
            blindsInput.addEventListener('input', (ev) => { r.blinds = ev.target.value; if(rows[currentIndex] && rows[currentIndex].id === r.id) updateVisibleBlinds(); });
          }
          if(durInput){
            durInput.addEventListener('input', (ev) => { const v = parseInt(ev.target.value,10); r.duration = Number.isFinite(v) && v>0 ? v : 1; if(rows[currentIndex] && rows[currentIndex].id === r.id){ initialRemaining = r.duration * 60; remaining = initialRemaining; updateCountdownDisplay(); } });
          }
        });
      }

      function selectRow(id){
        selectedId = id;
        Array.from(structureBody.querySelectorAll('tr')).forEach(tr => { tr.style.outline = tr.dataset.id === id ? '2px solid rgba(255,255,255,0.03)' : 'none'; });
      }

      function setCurrentById(id){ const idx = rows.findIndex(r => r.id === id); if(idx === -1) return; setCurrentIndex(idx); }

      function setCurrentIndex(idx){
        if(idx < 0 || idx >= rows.length) return;
        currentIndex = idx;
        const r = rows[currentIndex];
        renderRows();
        updateVisibleBlinds();
        roundLabel.textContent = r.type === 'break' ? 'Break' : ('Round ' + getRoundNumberForIndex(currentIndex));
        bigSub.textContent = r.type === 'break' ? 'Break' : ('Level ' + getRoundNumberForIndex(currentIndex));
        initialRemaining = r.duration * 60;
        remaining = initialRemaining;
        updateCountdownDisplay();
        stopTimer();
        statusEl.textContent = 'Ready';
      }

      function getRoundNumberForIndex(idx){ return rows.slice(0, idx+1).filter(x => x.type === 'level').length; }
      function findNextIndex(idx){ return idx + 1 < rows.length ? idx + 1 : -1; }

      function updateVisibleBlinds(){
        const r = rows[currentIndex];
        if(!r) return;
        currentBlindsEl.textContent = r.type === 'break' ? '-' : (r.blinds || '-');
        const nextIdx = findNextIndex(currentIndex);
        const next = nextIdx === -1 ? null : rows[nextIdx];
        nextBlindsEl.textContent = next ? (next.type === 'break' ? '-' : (next.blinds || '-')) : '-';
      }

      function updateCountdownDisplay(){
        const m = Math.floor(remaining/60).toString().padStart(2,'0');
        const s = (remaining%60).toString().padStart(2,'0');
        countdownEl.textContent = `${m}:${s}`;
      }

      // Main tick: when reaching 0 clear interval and start repeating cues for chosen delay
      // Configuration for repeating cue behavior:
      const ADVANCE_DELAY_MS = 3000; // total time to run repeating beep+flash before advancing
      const BEEP_INTERVAL_MS = 500;  // repeat beep every X ms
      const PULSE_MS = 500;          // flash pulse duration (ms) - sets CSS animation-duration

      function tick(){
        if(remaining > 0){
          remaining--;
          updateCountdownDisplay();
          return;
        }
        // stop the interval immediately so we don't queue multiple advances
        if(timer){
          clearInterval(timer);
          timer = null;
          playing = false;
        }
        // Start repeating beep+flash for ADVANCE_DELAY_MS, then advance once
        runRepeatedCues(ADVANCE_DELAY_MS, BEEP_INTERVAL_MS, PULSE_MS, () => {
          advanceToNextAndAutoStart();
        });
      }

      function startTimer(){ if(playing) return; if(remaining <= 0) remaining = initialRemaining || 0; const ctx = ensureAudioContext(); if(ctx && ctx.state === 'suspended'){ ctx.resume().catch(()=>{}); } timer = setInterval(tick, 1000); playing = true; statusEl.textContent = 'Running'; }
      function pauseTimer(){ if(timer) clearInterval(timer); timer = null; playing = false; statusEl.textContent = 'Paused'; }
      function stopTimer(){ pauseTimer(); }
      function restartTimer(){ remaining = initialRemaining; updateCountdownDisplay(); stopTimer(); statusEl.textContent = 'Ready'; }

      function advanceToNextAndAutoStart(){
        const nextIdx = findNextIndex(currentIndex);
        if(nextIdx === -1){ stopTimer(); remaining = 0; updateCountdownDisplay(); statusEl.textContent = 'Finished'; return; }
        currentIndex = nextIdx;
        const r = rows[currentIndex];
        renderRows();
        updateVisibleBlinds();
        roundLabel.textContent = r.type === 'break' ? 'Break' : ('Round ' + getRoundNumberForIndex(currentIndex));
        bigSub.textContent = r.type === 'break' ? 'Break' : ('Level ' + getRoundNumberForIndex(currentIndex));
        initialRemaining = r.duration * 60;
        remaining = initialRemaining;
        updateCountdownDisplay();
        if(timer) clearInterval(timer);
        timer = setInterval(tick, 1000);
        playing = true;
        statusEl.textContent = 'Running';
      }

      // Fullscreen helpers
      function isFullscreenSupported() {
        return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled);
      }
      function enterNativeFullscreen(el){
        if (el.requestFullscreen) return el.requestFullscreen();
        if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
        if (el.msRequestFullscreen) return el.msRequestFullscreen();
        return Promise.reject(new Error('No native fullscreen'));
      }
      function exitNativeFullscreen(){
        if (document.exitFullscreen) return document.exitFullscreen();
        if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
        if (document.msExitFullscreen) return document.msExitFullscreen();
        return Promise.reject(new Error('No native fullscreen'));
      }
      function isInNativeFullscreen(){
        return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
      }
      function enterFallback() {
        fsTarget.classList.add('fs-fullscreen');
        fallbackActive = true;
        fsBtn.textContent = 'Exit Fullscreen';
      }
      function exitFallback() {
        fsTarget.classList.remove('fs-fullscreen');
        fallbackActive = false;
        fsBtn.textContent = 'Enter Fullscreen';
      }

      async function toggleFullscreen(){
        if (isInNativeFullscreen()) {
          await exitNativeFullscreen().catch(()=>{});
          fsBtn.textContent = 'Enter Fullscreen';
          return;
        }
        if (isFullscreenSupported()) {
          try {
            await enterNativeFullscreen(fsTarget);
            fsBtn.textContent = 'Exit Fullscreen';
            return;
          } catch (e) {
            // fall through to fallback
          }
        }
        if (!fallbackActive) enterFallback(); else exitFallback();
      }

      function onFullscreenChange() {
        if (isInNativeFullscreen()) fsBtn.textContent = 'Exit Fullscreen';
        else if (fallbackActive) fsBtn.textContent = 'Exit Fullscreen';
        else fsBtn.textContent = 'Enter Fullscreen';
      }

      // Buttons and structure mutation
      addLevelBtn.addEventListener('click', () => { const newRow = createRowObj('level', '', '200/400', 10); if(selectedId){ const idx = rows.findIndex(r=>r.id===selectedId); rows.splice(idx+1,0,newRow); } else rows.push(newRow); renderRows(); });
      addBreakBtn.addEventListener('click', () => { const newRow = createRowObj('break', 'Break', '', 5); if(selectedId){ const idx = rows.findIndex(r=>r.id===selectedId); rows.splice(idx+1,0,newRow); } else rows.push(newRow); renderRows(); });
      removeLevelBtn.addEventListener('click', () => {
        if(!selectedId) return;
        const idx = rows.findIndex(r=>r.id===selectedId);
        if(idx === -1) return;
        rows.splice(idx,1);
        if(rows.length === 0){ currentIndex = 0; selectedId = null; renderRows(); countdownEl.textContent = '00:00'; currentBlindsEl.textContent='-'; nextBlindsEl.textContent='-'; statusEl.textContent = 'No levels'; stopTimer(); return; }
        if(idx <= currentIndex && currentIndex > 0) currentIndex--;
        selectedId = null; renderRows(); setCurrentIndex(currentIndex);
      });

      startBtn.addEventListener('click', startTimer);
      pauseBtn.addEventListener('click', pauseTimer);
      restartBtn.addEventListener('click', restartTimer);
      restartToOneBtn.addEventListener('click', () => {
        if(rows.length === 0) return;
        let firstIdx = rows.findIndex(r => r.type === 'level'); if(firstIdx === -1) firstIdx = 0;
        setCurrentIndex(firstIdx); stopTimer(); statusEl.textContent = 'Reset to Level One';
      });

      fsBtn.addEventListener('click', toggleFullscreen);
      document.addEventListener('fullscreenchange', onFullscreenChange);
      document.addEventListener('webkitfullscreenchange', onFullscreenChange);
      document.addEventListener('MSFullscreenChange', onFullscreenChange);

// Zoom controls
let baseSize = 64;          // your normal "1x" size
let currentSize = baseSize * 2; // start at 5x zoom

// apply the initial zoom immediately
countdownEl.style.fontSize = currentSize + 'px';

zoomInBtn.addEventListener('click', () => {
  currentSize += 8;
  countdownEl.style.fontSize = currentSize + 'px';
});

zoomOutBtn.addEventListener('click', () => {
  if (currentSize > 24) {
    currentSize -= 8;
    countdownEl.style.fontSize = currentSize + 'px';
  }
});


      // Init defaults
      function initDefaults(){
        rows = [
          createRowObj('level','1','25/50',10),
          createRowObj('level','2','50/100',10),
          createRowObj('level','3','100/200',10),
          createRowObj('level','4','150/300',10),
          createRowObj('level','5','200/400',10),
          createRowObj('level','6','400/800',10),
          createRowObj('level','7','500/1000',10),
          createRowObj('level','8','750/1500',10),
          createRowObj('level','9','1000/2000',10),
          createRowObj('level','10','1250/2500',10)
        ];
        renderRows();
        const firstLevelIdx = rows.findIndex(r => r.type === 'level');
        setCurrentIndex(firstLevelIdx === -1 ? 0 : firstLevelIdx);
        currentBlindsEl.textContent = rows[currentIndex].blinds || '-';
        nextBlindsEl.textContent = rows[ findNextIndex(currentIndex) ] ? ( rows[ findNextIndex(currentIndex) ].blinds || '-' ) : '-';
        countdownEl.textContent = String(rows[currentIndex].duration).padStart(2,'0') + ':00';
      }

      initDefaults();
    })();
  </script>
</body>
</html>
